# Pro/g/ramming challenges
## 4 Paradigms
1. [CS] Complete Search (aka Brute Force)
2. [DC] Divide and Conquer
3. [G] Greedy
4. [DP] Dynamic Programming
Iterative and Recursive.
## 3 Steps
1. Strategical: Better algorithms and data structures.
2. Tactical: Solution Optimization. (dummy values for Greedy for Station Balance.)
3. Operational: Technical Optimization.
## Strings
* Hello World.
* FizzBuzz.
* atoi (K&R 43)
* lower (K&R 43)
* pseudo-RNG (K&R 46)
* htoi (K&R 46)
* squeeze (K&R 47)
* strcat (K&R 48)
* getbits (K&R 49)
* bitcount (K&R 50)
* reverse (K&R 76)
* itoa (K&R 64)
* itob (K&R 64)
* trim (K&R 65)
* atof (K&R 71)
* rev_polish_cal (K&R 76)
* swap (K&R 96)
* alloc_afree (K&R 101)
* strcpy (K&R 105)
* strcmp (K&R 106)
* count_keywords (K&R 134)
* getword (K&R 136)
* lookup_install (K&R 145)
* cat (K&R 162)
* is_string_balanced
## Sorts
* shellsort (K&R 62)
* quicksort (K&R 87) [DC]
* mergesort [DC]
* bubblesort
* insertionsort
* heapsort [DC]
## Searchs
* linear_search
* binary_search (K&R 58) [DC]
## Trees
* BST
* is_valid_BST/checkBST
* Trie
* Heap
* DFS (HR)
* BFS (HR)
* shortest_reach (HR)
* connected_cells (HR)
* Kruskal MST [G]
* Dijkstra SSSP [G]
## Numbers
* Fibonacci. (TDD, recursive, iterative.)
* Factorial. (TDD, recursive, iterative.)
* GCD. (TDD, recursive, iterative.)
* HPF.
* Caesar cipher.
* XOR process.
## Geometry
* makepoint (K&R 130)
* addpoint (K&R 130)
* ptinrect (K&R 130)
* canonrect (K&R 131)
## Finance
* bond_price
* share_price
* BSM
## Misc
* 8 Queens [CS]
* Rat Attack [CS]
* abcde/ghijk [CS]
* coin_change/make_change [DP][G]
* ransom_note
* RMQ/RSQ. (cp1 p.22)
* ice_cream_parlor. [bsearch]
* staircase. [recursive][memo][DP][iterative]
* lonely_integer. [bit manipulation]
* Greedy Activity Selection Problem. [G]
* Huffman Codes. [G]
* Station Balance. [G]
* minesweeper. (assign numbers + solve it)
* lowest_common_ancestor.

